{"version":3,"file":"index.js","mappings":"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","sources":["webpack://supersetEmbeddedSdk/webpack/universalModuleDefinition","webpack://supersetEmbeddedSdk/./node_modules/@superset-ui/switchboard/esm/switchboard.js","webpack://supersetEmbeddedSdk/webpack/bootstrap","webpack://supersetEmbeddedSdk/webpack/runtime/define property getters","webpack://supersetEmbeddedSdk/webpack/runtime/harmony module decorator","webpack://supersetEmbeddedSdk/webpack/runtime/hasOwnProperty shorthand","webpack://supersetEmbeddedSdk/webpack/runtime/make namespace object","webpack://supersetEmbeddedSdk/./src/guestTokenRefresh.ts","webpack://supersetEmbeddedSdk/./src/index.ts","webpack://supersetEmbeddedSdk/./src/const.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"supersetEmbeddedSdk\"] = factory();\n\telse\n\t\troot[\"supersetEmbeddedSdk\"] = factory();\n})(globalThis, function() {\nreturn ","(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n\n\n\n\n\n\n  // used to make unique ids\n\n\n\n\n  constructor({ port, name = 'switchboard', debug = false }) {this.port = void 0;this.name = void 0;this.methods = {};this.incrementor = 1;this.debugMode = void 0;\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n\n    port.addEventListener('message', async (event) => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else if (isEmit(message)) {\n        const { method, args } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n  }\n\n  async getMethodResult({\n    messageId,\n    method,\n    args })\n  {\n    const executor = this.methods[method];\n    if (executor == null) {\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined` };\n\n    }\n    try {\n      const result = await executor(args);\n      return {\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result };\n\n    } catch (err) {\n      this.logError(err);\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error` };\n\n    }\n  }\n\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod(methodName, executor) {\n    this.methods[methodName] = executor;\n  }\n\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonense.\n   * @returns whatever is returned from the method\n   */\n  get(method, args = undefined) {\n    return new Promise((resolve, reject) => {\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = (event) => {\n        const message = event.data;\n        if (message.messageId !== messageId) return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else {\n          const errStr = isError(message) ?\n          message.error :\n          'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args };\n\n      this.port.postMessage(message);\n    });\n  }\n\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method, args = undefined) {\n    const message = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args };\n\n    this.port.postMessage(message);\n  }\n\n  start() {\n    this.port.start();\n  }\n\n  log(...args) {\n    if (this.debugMode) {\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n\n  logError(...args) {\n    console.error(`[${this.name}]`, ...args);\n  }\n\n  getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\n\n\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nvar Actions;\n\n\n\n\n\n\n// helper types/functions for making sure wires don't get crossed\n(function (Actions) {Actions[\"GET\"] = \"get\";Actions[\"REPLY\"] = \"reply\";Actions[\"EMIT\"] = \"emit\";Actions[\"ERROR\"] = \"error\";})(Actions || (Actions = {}));\n\n\n\n\n\n\n\n\n\n\n\nfunction isGet(message) {\n  return message.switchboardAction === Actions.GET;\n}\n\n\n\n\n\n\n\nfunction isReply(message) {\n  return message.switchboardAction === Actions.REPLY;\n}\n\n\n\n\n\n\n\nfunction isEmit(message) {\n  return message.switchboardAction === Actions.EMIT;\n}\n\n\n\n\n\n\n\nfunction isError(message) {\n  return message.switchboardAction === Actions.ERROR;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Switchboard, \"Switchboard\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isGet, \"isGet\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isReply, \"isReply\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isEmit, \"isEmit\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isError, \"isError\", \"/Users/aaron/work/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport const REFRESH_TIMING_BUFFER_MS = 5000 // refresh guest token early to avoid failed superset requests\nexport const MIN_REFRESH_WAIT_MS = 10000 // avoid blasting requests as fast as the cpu can handle\nexport const DEFAULT_TOKEN_EXP_MS = 300000 // (5 min) used only when parsing guest token exp fails\n\n// when do we refresh the guest token?\nexport function getGuestTokenRefreshTiming(currentGuestToken: string) {\n  const parsedJwt = JSON.parse(Buffer.from(currentGuestToken.split('.')[1], 'base64').toString());\n  // if exp is int, it is in seconds, but Date() takes milliseconds\n  const exp = new Date(/[^0-9\\.]/g.test(parsedJwt.exp) ? parsedJwt.exp : parseFloat(parsedJwt.exp) * 1000);\n  const isValidDate = exp.toString() !== 'Invalid Date';\n  const ttl = isValidDate ? Math.max(MIN_REFRESH_WAIT_MS, exp.getTime() - Date.now()) : DEFAULT_TOKEN_EXP_MS;\n  return ttl - REFRESH_TIMING_BUFFER_MS;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { IFRAME_COMMS_MESSAGE_TYPE } from './const';\n\n// We can swap this out for the actual switchboard package once it gets published\nimport { Switchboard } from '@superset-ui/switchboard';\nimport { getGuestTokenRefreshTiming } from './guestTokenRefresh';\n\n/**\n * The function to fetch a guest token from your Host App's backend server.\n * The Host App backend must supply an API endpoint\n * which returns a guest token with appropriate resource access.\n */\nexport type GuestTokenFetchFn = () => Promise<string>;\n\nexport type UiConfigType = {\n  hideTitle?: boolean\n  hideTab?: boolean\n  hideChartControls?: boolean\n}\n\nexport type EmbedDashboardParams = {\n  /** The id provided by the embed configuration UI in Superset */\n  id: string\n  /** The domain where Superset can be located, with protocol, such as: https://superset.example.com */\n  supersetDomain: string\n  /** The html element within which to mount the iframe */\n  mountPoint: HTMLElement\n  /** A function to fetch a guest token from the Host App's backend server */\n  fetchGuestToken: GuestTokenFetchFn\n  /** The dashboard UI config: hideTitle, hideTab, hideChartControls **/\n  dashboardUiConfig?: UiConfigType\n  /** Are we in debug mode? */\n  debug?: boolean\n}\n\nexport type Size = {\n  width: number, height: number\n}\n\nexport type EmbeddedDashboard = {\n  getScrollSize: () => Promise<Size>\n  unmount: () => void\n}\n\n/**\n * Embeds a Superset dashboard into the page using an iframe.\n */\nexport async function embedDashboard({\n  id,\n  supersetDomain,\n  mountPoint,\n  fetchGuestToken,\n  dashboardUiConfig,\n  debug = false\n}: EmbedDashboardParams): Promise<EmbeddedDashboard> {\n  function log(...info: unknown[]) {\n    if (debug) {\n      console.debug(`[superset-embedded-sdk][dashboard ${id}]`, ...info);\n    }\n  }\n\n  log('embedding');\n\n  function calculateConfig() {\n    let configNumber = 0\n    if(dashboardUiConfig) {\n      if(dashboardUiConfig.hideTitle) {\n        configNumber += 1\n      }\n      if(dashboardUiConfig.hideTab) {\n        configNumber += 2\n      }\n      if(dashboardUiConfig.hideChartControls) {\n        configNumber += 8\n      }\n    }\n    return configNumber\n  }\n\n  async function mountIframe(): Promise<Switchboard> {\n    return new Promise(resolve => {\n      const iframe = document.createElement('iframe');\n      const dashboardConfig = dashboardUiConfig ? `?uiConfig=${calculateConfig()}` : \"\"\n\n      // setup the iframe's sandbox configuration\n      iframe.sandbox.add(\"allow-same-origin\"); // needed for postMessage to work\n      iframe.sandbox.add(\"allow-scripts\"); // obviously the iframe needs scripts\n      iframe.sandbox.add(\"allow-presentation\"); // for fullscreen charts\n      iframe.sandbox.add(\"allow-downloads\"); // for downloading charts as image\n      // add these ones if it turns out we need them:\n      // iframe.sandbox.add(\"allow-top-navigation\");\n      // iframe.sandbox.add(\"allow-forms\");\n\n      // add the event listener before setting src, to be 100% sure that we capture the load event\n      iframe.addEventListener('load', () => {\n        // MessageChannel allows us to send and receive messages smoothly between our window and the iframe\n        // See https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API\n        const commsChannel = new MessageChannel();\n        const ourPort = commsChannel.port1;\n        const theirPort = commsChannel.port2;\n\n        // Send one of the message channel ports to the iframe to initialize embedded comms\n        // See https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n        // we know the content window isn't null because we are in the load event handler.\n        iframe.contentWindow!.postMessage(\n          { type: IFRAME_COMMS_MESSAGE_TYPE, handshake: \"port transfer\" },\n          supersetDomain,\n          [theirPort],\n        )\n        log('sent message channel to the iframe');\n\n        // return our port from the promise\n        resolve(new Switchboard({ port: ourPort, name: 'superset-embedded-sdk', debug }));\n      });\n\n      iframe.src = `${supersetDomain}/embedded/${id}${dashboardConfig}`;\n      mountPoint.replaceChildren(iframe);\n      log('placed the iframe')\n    });\n  }\n\n  const [guestToken, ourPort] = await Promise.all([\n    fetchGuestToken(),\n    mountIframe(),\n  ]);\n\n  ourPort.emit('guestToken', { guestToken });\n  log('sent guest token');\n\n  async function refreshGuestToken() {\n    const newGuestToken = await fetchGuestToken();\n    ourPort.emit('guestToken', { guestToken: newGuestToken });\n    setTimeout(refreshGuestToken, getGuestTokenRefreshTiming(newGuestToken));\n  }\n\n  setTimeout(refreshGuestToken, getGuestTokenRefreshTiming(guestToken));\n\n  function unmount() {\n    log('unmounting');\n    mountPoint.replaceChildren();\n  }\n\n  const getScrollSize = () => ourPort.get<Size>('getScrollSize');\n\n  return {\n    getScrollSize,\n    unmount,\n  };\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport const IFRAME_COMMS_MESSAGE_TYPE = \"__embedded_comms__\";\n"],"names":["root","factory","exports","module","define","amd","globalThis","enterModule","reactHotLoaderGlobal","undefined","__signature__","default","signature","a","Actions","reactHotLoader","leaveModule","Switchboard","constructor","port","name","debug","this","methods","incrementor","debugMode","addEventListener","async","event","log","message","data","isGet","postMessage","getMethodResult","isEmit","method","args","executor","messageId","switchboardAction","ERROR","error","result","REPLY","err","logError","defineMethod","methodName","get","Promise","resolve","reject","getNewMessageId","listener","removeEventListener","isReply","errStr","isError","Error","start","GET","emit","EMIT","console","__reactstandin__regenerateByEval","key","code","eval","register","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","id","loaded","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","hmd","create","children","set","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","getGuestTokenRefreshTiming","currentGuestToken","parsedJwt","JSON","parse","Buffer","from","split","toString","exp","Date","test","parseFloat","Math","max","getTime","now","embedDashboard","supersetDomain","mountPoint","fetchGuestToken","dashboardUiConfig","info","guestToken","ourPort","all","iframe","document","createElement","dashboardConfig","configNumber","hideTitle","hideTab","hideChartControls","calculateConfig","sandbox","add","commsChannel","MessageChannel","port1","theirPort","port2","contentWindow","type","handshake","src","replaceChildren","mountIframe","setTimeout","refreshGuestToken","newGuestToken","getScrollSize","unmount"],"sourceRoot":""}